"""
Settings service for managing .env file configuration.
"""
import os
from typing import Dict, Optional
from pathlib import Path


class SettingsService:
    """Service for reading and writing .env file"""

    def __init__(self, env_path: Optional[str] = None):
        """
        Initialize settings service.

        Args:
            env_path: Path to .env file. If None, uses backend/.env
        """
        if env_path is None:
            # Default to backend/.env
            backend_dir = Path(__file__).parent.parent.parent
            env_path = backend_dir / ".env"

        self.env_path = Path(env_path)

    def read_env(self) -> Dict[str, str]:
        """
        Read all settings from .env file.

        Returns:
            Dictionary of key-value pairs from .env
        """
        settings = {}

        if not self.env_path.exists():
            return settings

        try:
            with open(self.env_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()

                    # Skip empty lines and comments
                    if not line or line.startswith('#'):
                        continue

                    # Parse key=value
                    if '=' in line:
                        key, value = line.split('=', 1)
                        key = key.strip()
                        value = value.strip()

                        # Remove quotes if present
                        if value.startswith('"') and value.endswith('"'):
                            value = value[1:-1]
                        elif value.startswith("'") and value.endswith("'"):
                            value = value[1:-1]

                        settings[key] = value

        except Exception as e:
            print(f"[SettingsService] Error reading .env: {e}")

        return settings

    def write_env(self, updates: Dict[str, str]) -> bool:
        """
        Update .env file with new values (merge with existing).

        Args:
            updates: Dictionary of key-value pairs to update

        Returns:
            True if successful, False otherwise
        """
        try:
            # Read existing settings
            existing = self.read_env()

            # Merge updates
            existing.update(updates)

            # Write back to file
            with open(self.env_path, 'w', encoding='utf-8') as f:
                f.write("# Personal Growth OS Configuration\n")
                f.write("# This file is auto-generated by the settings UI\n\n")

                # Group by category
                categories = {
                    "LLM Provider": ["LLM_PROVIDER"],
                    "OpenAI Settings": [
                        "OPENAI_API_KEY",
                        "OPENAI_API_BASE",
                        "OPENAI_MODEL"
                    ],
                    "Anthropic (Claude) Settings": [
                        "ANTHROPIC_API_KEY",
                        "ANTHROPIC_API_BASE",
                        "ANTHROPIC_MODEL"
                    ],
                    "Ollama Settings": [
                        "OLLAMA_BASE_URL",
                        "OLLAMA_MODEL"
                    ],
                    "Other Settings": []
                }

                written_keys = set()

                # Write categorized settings
                for category, keys in categories.items():
                    if category == "Other Settings":
                        continue

                    # Check if any keys in this category exist
                    category_has_values = any(k in existing for k in keys)
                    if not category_has_values:
                        continue

                    f.write(f"# {category}\n")
                    for key in keys:
                        if key in existing:
                            value = existing[key]
                            # Quote values with spaces
                            if ' ' in value:
                                value = f'"{value}"'
                            f.write(f"{key}={value}\n")
                            written_keys.add(key)
                    f.write("\n")

                # Write remaining settings
                remaining = {k: v for k, v in existing.items() if k not in written_keys}
                if remaining:
                    f.write("# Other Settings\n")
                    for key, value in remaining.items():
                        if ' ' in value:
                            value = f'"{value}"'
                        f.write(f"{key}={value}\n")

            print(f"[SettingsService] .env file updated successfully")
            return True

        except Exception as e:
            print(f"[SettingsService] Error writing .env: {e}")
            return False

    def get_setting(self, key: str, default: Optional[str] = None) -> Optional[str]:
        """
        Get a single setting value.

        Args:
            key: Setting key
            default: Default value if not found

        Returns:
            Setting value or default
        """
        settings = self.read_env()
        return settings.get(key, default)


# Singleton instance
_settings_service: Optional[SettingsService] = None


def get_settings_service() -> SettingsService:
    """Get or create settings service instance"""
    global _settings_service
    if _settings_service is None:
        _settings_service = SettingsService()
    return _settings_service
