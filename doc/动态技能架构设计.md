# 动态技能架构设计 (Dynamic Skills Architecture)

> 基于 Claude Code Skills 设计理念的 **动态技能注入 + 通用工具工厂** 架构方案

**创建日期**: 2025-12-05
**状态**: 设计完成，待实施
**作者**: Claude Code + 用户协作设计

---

## 一、核心设计理念

### 1.1 脑手分离 (Brain-Hand Separation)

| 层级 | 职责 | 载体 |
|------|------|------|
| **脑 (Brain)** | 业务流程、判断逻辑、参数校验、异常处理策略 | **Markdown (SOP)** |
| **手 (Hand)** | 原子操作（CRUD、发请求、改配置） | **Python 函数** |

**核心思想**:
- Python 代码只负责最底层的"原子操作"，不包含任何业务判断
- 业务逻辑全部文档化，可以热更新而无需重启后端

### 1.2 动态上下文 (JIT Context)

- LLM 不会一次性加载所有工具
- 采用 **"后缀注入 (Suffix Injection)"** 技术：仅在用户需要时，将特定技能的 SOP 拼接到对话历史的末尾
- **优势**: 最大化利用 KV Cache（降低延迟和成本），同时实现物理级别的权限隔离

### 1.3 通用适配器 (Universal Adapter)

- 使用 **ToolFactory** 模式，将现有的 Service/CRUD 函数一键封装为 AI 可用的工具
- 消除重复的 `try-except` 和 `DB Session` 管理代码

---

## 二、关键设计决策

| 决策点 | 选择 | 原因 |
|-------|------|------|
| 会话继承 | **滑动窗口 + 后缀注入** | 保留最近 N 条消息 + SOP 放最后，KV Cache 命中率最高 |
| Pydantic 处理 | **保持嵌套** | 让 LLM 生成完整 JSON 对象，与现有 Schema 兼容 |
| UI 指令 | **Toast + 数据刷新** | MVP 先实现这两个高频场景 |
| 执行模式 | **多轮续做** | Specialist 可自动判断是否有后续任务 |
| MVP Skill | **task_manager** | 任务增删改查 + Snooze，覆盖核心业务 |

---

## 三、系统分层架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      前端层 (Vue - The Copilot UI)               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │  文本流通道   │  │  指令流通道   │  │    技能状态显示       │  │
│  │ (AI 对话回复) │  │ (UI_Command) │  │ (正在加载xxx模块...)  │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
├─────────────────────────────────────────────────────────────────┤
│                      接口层 (FastAPI - The Gateway)              │
│  ┌──────────────┐  ┌──────────────────────────────────────┐    │
│  │  RESTful API  │  │  Chat Endpoint (/api/chat/...)       │    │
│  │  (原有不动)   │  │  (连接 LangGraph Orchestrator)        │    │
│  └──────────────┘  └──────────────────────────────────────┘    │
├─────────────────────────────────────────────────────────────────┤
│                      引擎层 (LangGraph - The Orchestrator)       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ Router Node  │─►│ Loader Node  │─►│ Specialist Node  │◄─┐   │
│  │ (意图识别)   │  │ (技能加载)   │  │ (执行任务)       │  │   │
│  └──────────────┘  └──────────────┘  └────────┬─────────┘  │   │
│                                               │             │   │
│                                        ┌──────▼──────┐      │   │
│                                        │Continue Check│──────┘   │
│                                        │ (多轮续做)   │          │
│                                        └─────────────┘          │
├─────────────────────────────────────────────────────────────────┤
│                      资源层 (The Registry)                       │
│  ┌──────────────────────┐  ┌──────────────────────────────┐    │
│  │     技能库 (Skills)   │  │       工具库 (Tools)          │    │
│  │  *.md 文件            │  │  ToolFactory 自动生成         │    │
│  │  - YAML frontmatter  │  │  - DB Tools (CRUD)            │    │
│  │  - SOP 正文          │  │  - System Tools               │    │
│  └──────────────────────┘  └──────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

---

## 四、核心组件设计

### 4.1 ToolFactory 类

**文件**: `backend/app/tools/factory.py`

```python
from typing import Callable, Type, Optional
from pydantic import BaseModel
from langchain_core.tools import BaseTool, tool
from app.db.database import get_db

class ToolFactory:
    """将 CRUD 函数自动转换为 LangChain Tool"""

    @staticmethod
    def from_crud(
        func: Callable,
        name: str,
        description: str,
        args_schema: Optional[Type[BaseModel]] = None
    ) -> BaseTool:
        """
        将 CRUD 函数转换为 LangChain Tool

        - 自动注入 DB Session
        - 自动包装错误处理
        - 保持 Pydantic Schema 嵌套结构
        """
        def wrapped_func(**kwargs):
            db = next(get_db())
            try:
                result = func(db, **kwargs)
                return str(result) if result else "操作成功"
            except Exception as e:
                return f"操作失败: {str(e)}"
            finally:
                db.close()

        return tool(
            name=name,
            description=description,
            args_schema=args_schema
        )(wrapped_func)
```

### 4.2 工具注册表

**文件**: `backend/app/tools/__init__.py`

```python
from dataclasses import dataclass
from typing import Callable, Type, Optional, Dict
from pydantic import BaseModel

from app.crud import crud_task, crud_note, crud_link
from app.schemas.task import TaskCreate, TaskUpdate
from app.tools.schemas import TaskIdSchema, TaskListSchema, TaskSnoozeSchema

@dataclass
class ToolDef:
    """工具定义"""
    func: Callable
    description: str
    args_schema: Optional[Type[BaseModel]] = None

# 工具清单 - 声明式配置
TOOL_REGISTRY: Dict[str, ToolDef] = {
    # Task 工具
    "task_get": ToolDef(crud_task.get_task, "获取任务详情", TaskIdSchema),
    "task_list": ToolDef(crud_task.get_tasks, "列出任务", TaskListSchema),
    "task_create": ToolDef(crud_task.create_task, "创建新任务", TaskCreate),
    "task_update": ToolDef(crud_task.update_task, "更新任务", TaskUpdate),
    "task_delete": ToolDef(crud_task.delete_task, "删除任务", TaskIdSchema),
    "task_snooze": ToolDef(crud_task.snooze_task, "延后任务", TaskSnoozeSchema),

    # Note 工具
    "note_search": ToolDef(
        vector_store.search_similar_notes,
        "语义搜索笔记",
        NoteSearchSchema
    ),
    "note_create": ToolDef(crud_note.create_note, "创建笔记", NoteCreate),

    # Link 工具
    "link_create": ToolDef(crud_link.create_link, "创建笔记链接", NoteLinkCreate),
}
```

### 4.3 SkillRegistry 类

**文件**: `backend/app/skills/registry.py`

```python
import yaml
from pathlib import Path
from dataclasses import dataclass
from typing import Dict, List, Optional

@dataclass
class SkillDef:
    """技能定义"""
    name: str
    description: str
    tools: List[str]
    sop: str
    inherit_history: bool = True

class SkillRegistry:
    """技能注册表 - 加载和管理 Markdown 技能定义"""

    def __init__(self, skills_dir: Path = None):
        if skills_dir is None:
            skills_dir = Path(__file__).parent
        self.skills_dir = skills_dir
        self._skills_cache: Dict[str, SkillDef] = {}

    def load_skill(self, skill_name: str) -> SkillDef:
        """加载技能定义"""
        if skill_name in self._skills_cache:
            return self._skills_cache[skill_name]

        md_path = self.skills_dir / f"{skill_name}.md"
        if not md_path.exists():
            raise ValueError(f"技能 '{skill_name}' 不存在")

        content = md_path.read_text(encoding="utf-8")

        # 解析 YAML frontmatter
        if content.startswith("---"):
            parts = content.split("---", 2)
            if len(parts) >= 3:
                metadata = yaml.safe_load(parts[1])
                sop = parts[2].strip()
            else:
                raise ValueError(f"技能文件格式错误: {skill_name}")
        else:
            raise ValueError(f"技能文件缺少 frontmatter: {skill_name}")

        skill = SkillDef(
            name=metadata.get("name", skill_name),
            description=metadata.get("description", ""),
            tools=metadata.get("tools", []),
            sop=sop,
            inherit_history=metadata.get("inherit_history", True)
        )

        self._skills_cache[skill_name] = skill
        return skill

    def get_all_skill_descriptions(self) -> List[dict]:
        """获取所有技能的简要描述（供 Orchestrator 判断）"""
        descriptions = []
        for md_file in self.skills_dir.glob("*.md"):
            try:
                skill = self.load_skill(md_file.stem)
                descriptions.append({
                    "name": skill.name,
                    "description": skill.description
                })
            except Exception:
                continue
        return descriptions
```

### 4.4 LangGraph 状态机

**文件**: `backend/app/agents/orchestrator/state.py`

```python
from typing import TypedDict, Optional, List, Annotated
from langchain_core.messages import BaseMessage
from langgraph.graph.message import add_messages

class OrchestratorState(TypedDict):
    """Orchestrator 状态定义"""
    messages: Annotated[List[BaseMessage], add_messages]
    current_skill: Optional[str]  # 当前激活的技能
    skill_sop: Optional[str]      # 技能 SOP（后缀注入）
    available_tools: List[str]    # 当前可用工具列表
```

**文件**: `backend/app/agents/orchestrator/graph.py`

```python
from langgraph.graph import StateGraph, END
from langchain_core.messages import SystemMessage

def apply_sliding_window(messages: List[BaseMessage], window_size: int = 10):
    """滑动窗口 - 保留最近 N 条消息"""
    system_msgs = [m for m in messages if isinstance(m, SystemMessage)]
    other_msgs = [m for m in messages if not isinstance(m, SystemMessage)]
    recent_msgs = other_msgs[-window_size:] if len(other_msgs) > window_size else other_msgs
    return system_msgs + recent_msgs

def create_orchestrator_graph():
    """创建 Orchestrator 状态机"""
    graph = StateGraph(OrchestratorState)

    # 添加节点
    graph.add_node("router", router_node)
    graph.add_node("loader", loader_node)
    graph.add_node("specialist", specialist_node)
    graph.add_node("continue_check", continue_check_node)
    graph.add_node("idle_response", idle_response_node)

    # 添加边
    graph.set_entry_point("router")
    graph.add_conditional_edges("router", route_decision)
    graph.add_edge("loader", "specialist")
    graph.add_edge("specialist", "continue_check")
    graph.add_conditional_edges("continue_check", should_continue)
    graph.add_edge("idle_response", END)

    return graph.compile(checkpointer=get_checkpointer())
```

---

## 五、Skill Markdown 模板

**文件**: `backend/app/skills/task_manager.md`

```markdown
---
name: task_manager
description: 任务管理技能 - 创建、更新、删除、延后任务
tools:
  - task_get
  - task_list
  - task_create
  - task_update
  - task_delete
  - task_snooze
inherit_history: true
---

## 角色设定

你是任务管理专家，帮助用户高效管理任务。

## 操作流程 (SOP)

### 创建任务
1. 确认任务标题和描述
2. 询问项目归属（默认项目 ID=1）
3. 询问优先级（1-5，默认3）
4. 可选：询问计划时间（start_time, end_time）
5. 调用 task_create 工具
6. 返回创建结果，发送 UI 指令刷新任务列表

### 更新任务
1. 首先使用 task_get 或 task_list 确认任务存在
2. 确认要修改的字段
3. 调用 task_update 工具
4. 发送 UI 刷新指令

### 延后任务
1. 确认任务 ID
2. 询问延后到什么时间
3. 调用 task_snooze 工具
4. 通知用户并刷新

### 删除任务
1. 确认任务 ID
2. **必须二次确认**: "确定要删除任务 [标题] 吗？"
3. 用户确认后调用 task_delete 工具
4. 发送 UI 刷新指令

## 注意事项
- 删除操作需要二次确认
- 所有时间使用 ISO 8601 格式
- 项目 ID=1 是系统默认项目，不可删除
- 创建任务后发送 {"type": "refresh", "payload": {"target": "tasks"}}
```

---

## 六、UI 指令通道

### 6.1 指令格式

```python
class UICommand(BaseModel):
    type: Literal["toast", "refresh", "navigate", "modal"]
    payload: dict

# 示例
{"type": "toast", "payload": {"message": "任务创建成功", "type": "success"}}
{"type": "refresh", "payload": {"target": "tasks"}}
```

### 6.2 SSE 事件类型

```python
class RunEvent(str, Enum):
    RUN_STARTED = "RunStarted"
    RUN_CONTENT = "RunContent"
    RUN_COMPLETED = "RunCompleted"
    RUN_ERROR = "RunError"
    TOOL_CALL_STARTED = "ToolCallStarted"
    TOOL_CALL_COMPLETED = "ToolCallCompleted"
    # 新增
    UI_COMMAND = "UICommand"  # 前端指令
    SKILL_ACTIVATED = "SkillActivated"  # 技能加载通知
```

### 6.3 前端处理

```typescript
// frontend/src/stores/chatStore.ts
case 'UICommand':
  handleUICommand(event.payload)
  break

function handleUICommand(command: UICommand) {
  switch (command.type) {
    case 'toast':
      ElMessage[command.payload.type](command.payload.message)
      break
    case 'refresh':
      if (command.payload.target === 'tasks') {
        taskStore.fetchTasks()
      }
      break
  }
}
```

---

## 七、工作流程示例

### 场景：用户说"创建一个明天下午3点的会议准备任务"

```
1. [Router Node]
   - 接收用户消息
   - LLM 判断意图: 需要创建任务 → activate_skill("task_manager")

2. [Loader Node]
   - 读取 skills/task_manager.md
   - 提取 tools: [task_get, task_list, task_create, ...]
   - 滑动窗口: 保留最近 10 条消息
   - 后缀注入: 将 SOP 追加到 messages 末尾

3. [Specialist Node]
   - 阅读 SOP 中的"创建任务"流程
   - 解析用户意图: 标题="会议准备", 时间=明天15:00
   - 调用 task_create 工具
   - 工具返回: {"id": 42, "title": "会议准备", ...}
   - 发送 UI 指令: {"type": "refresh", "payload": {"target": "tasks"}}

4. [Continue Check]
   - LLM 判断: 任务已完成，无后续
   - → END

5. [前端]
   - 收到 RunContent: "已为您创建任务「会议准备」，安排在明天下午3点"
   - 收到 UICommand: 执行 taskStore.fetchTasks() 刷新列表
   - 收到 RunCompleted: 对话结束
```

---

## 八、实施路线图

### Step 0: 方案文档化 ✅
- [x] 创建 `doc/动态技能架构设计.md`

### Step 1: ToolFactory + 工具注册表
- [ ] `backend/app/tools/factory.py`
- [ ] `backend/app/tools/__init__.py`
- [ ] `backend/app/tools/schemas.py`

### Step 2: SkillRegistry + Markdown
- [ ] `backend/app/skills/registry.py`
- [ ] `backend/app/skills/task_manager.md`

### Step 3: LangGraph Orchestrator
- [ ] `backend/app/agents/orchestrator/state.py`
- [ ] `backend/app/agents/orchestrator/graph.py`

### Step 4: Chat API 改造
- [ ] 修改 `backend/app/api/endpoints/chat.py`
- [ ] 添加 UI_COMMAND 事件

### Step 5: 前端对接
- [ ] 修改 `frontend/src/stores/chatStore.ts`
- [ ] UICommand handler

---

## 九、架构优势

| 优势 | 说明 |
|------|------|
| **开发效率** | 新增功能只需写 Markdown + 配置行 |
| **维护成本** | 业务逻辑变更只改 Markdown，无需重启 |
| **性能优化** | 后缀注入保护 KV Cache，响应快、Token 成本低 |
| **代码整洁** | 消除重复的 try-except 和 Session 管理 |
| **权限隔离** | 每个 Skill 只能访问声明的工具 |
| **可观测性** | 技能加载状态、工具调用全程可追踪 |

---

## 十、参考资料

- [Claude Code Skills 设计](https://github.com/anthropics/claude-code)
- [LangGraph 1.0 文档](https://langchain-ai.github.io/langgraph/)
- [本项目 Agent 实现](../backend/app/agents/task_igniter_langgraph.py)
