### **1. 前端详细设计 (Vue 3 + TypeScript + Element Plus)**

前端是用户的“驾驶舱”，它的设计原则是**“响应式、组件化、状态驱动”**。

#### **1.1. 核心设计理念**

*   **组件化 (Component-Based):** 我们将把UI拆分为一系列可复用、高内聚的组件。例如，一个“任务项”是组件，一个“标签”是组件，整个“任务列表”也是由多个“任务项”组件构成的。
*   **状态驱动 (State-Driven):** 界面上显示的一切，都由一个统一的“状态管理器”（Pinia）来驱动。我们不直接操作DOM，而是通过改变状态来让界面自动更新。例如，要将一个任务标记为完成，我们只需改变状态中该任务的`status`字段，界面会自动重新渲染。

#### **1.2. 目录与组件结构 (设想)**

```
src/
├── api/          # 封装所有对后端API的请求
│   ├── taskService.ts
│   └── noteService.ts
├── assets/       # 静态资源 (CSS, 图片)
├── components/   # 可复用的基础组件
│   ├── common/
│   │   ├── Tag.vue
│   │   └── LoadingSpinner.vue
│   ├── chat/
│   │   ├── ChatWindow.vue
│   │   └── Message.vue
│   ├── tasks/
│   │   ├── TaskItem.vue
│   │   └── TaskList.vue
│   └── notes/
│       ├── NoteEditor.vue
│       └── NoteCard.vue
├── layouts/      # 页面布局组件
│   └── MainLayout.vue
├── stores/       # Pinia状态管理
│   ├── taskStore.ts
│   ├── noteStore.ts
│   └── chatStore.ts
└── views/        # 页面级组件 (路由)
    ├── DashboardView.vue
    ├── TasksView.vue
    ├── NotesView.vue
    └── ReviewView.vue
```

#### **1.3. 核心页面与组件功能**

*   **`MainLayout.vue`**: 整个应用的骨架，包含一个固定的侧边栏导航和一个动态内容区域。
*   **`ChatWindow.vue`**: 可能是最核心的交互组件。它负责：
    *   渲染对话历史。
    *   处理用户的文本输入和文件拖拽上传。
    *   显示AI的“正在思考...”状态。
    *   渲染带有“可追溯”链接和“自信度”评分的特殊消息。
*   **`NoteEditor.vue`**: 一个富文本编辑器（可集成TipTap或CKEditor），用于创建和编辑笔记。它需要支持Markdown语法和简单的格式化。
*   **`TaskList.vue`**: 负责展示任务列表，并提供筛选（如“今天”、“本周”、“已完成”）和排序功能。
*   **`ReviewView.vue`**: 复盘仪表盘的容器。它将由多个子组件构成，如图表组件（使用ECharts或Chart.js）、数据卡片组件等，用于可视化展示复盘数据。

#### **1.4. 状态管理 (Pinia)**

我们将创建多个“Store”来分别管理不同模块的数据，实现关注点分离：
*   `taskStore.ts`: 存储所有任务数据，并提供添加、更新、删除任务的Action。
*   `noteStore.ts`: 存储笔记列表和当前正在查看的笔记内容。
*   `chatStore.ts`: 存储当前对话的上下文历史，方便发送给后端。

---

### **2. 后端详细设计 (FastAPI + LangGraph)**

后端是“中央指挥室”，它的设计原则是**“分层、解耦、面向服务”**。

#### **2.1. 核心设计理念**

*   **分层架构 (Layered Architecture):** 我们将采用经典的三层架构，确保代码逻辑清晰，易于维护和测试。
    1.  **API层 (API Layer)**: 处理HTTP请求，验证输入数据。
    2.  **服务层 (Service Layer)**: 实现所有核心业务逻辑。
    3.  **数据访问层 (Data Access Layer)**: 负责与数据库进行交互。
*   **Agentic设计**: 复杂的业务逻辑（如“任务启动仪式”）将不再是简单的函数调用，而是被封装成一个由**LangGraph**定义的、有状态的**Agent**。这使得我们可以构建出能够思考、决策和循环的复杂工作流。

#### **2.2. 目录与模块结构 (设想)**

```
app/
├── api/          # API层 (FastAPI Routers)
│   ├── endpoints/
│   │   ├── tasks.py
│   │   ├── notes.py
│   │   └── chat.py
│   └── deps.py   # 依赖注入
├── core/         # 核心配置
│   └── config.py
├── crud/         # 数据访问层 (CRUD操作)
│   ├── crud_task.py
│   └── crud_note.py
├── db/           # 数据库连接与模型
│   ├── database.py
│   └── models.py   # SQLAlchemy模型 (如果使用)
├── schemas/      # Pydantic模型 (用于数据验证和序列化)
│   ├── task.py
│   └── note.py
├── services/     # 服务层 (核心业务逻辑)
│   ├── task_service.py
│   ├── note_service.py
│   └── review_service.py
└── agents/       # Agentic工作流定义 (LangGraph)
    ├── task_igniter_agent.py
    └── review_generator_agent.py
```

#### **2.3. 核心模块功能**

*   **API层 (`/api/endpoints`)**: 这一层非常“薄”。它的唯一职责是：
    1.  定义API路由（如`@router.post("/tasks")`）。
    2.  使用Pydantic模型验证请求体的数据格式。
    3.  调用相应的**服务层**函数来处理业务逻辑。
    4.  返回服务层处理后的结果。
*   **服务层 (`/services`)**: 这一层是“厚”的，是业务逻辑的核心。
    *   `task_service.py`会包含`create_task()`、`get_all_tasks()`等函数。
    *   对于简单逻辑，它会直接调用**数据访问层**。
    *   对于复杂逻辑，例如创建一个需要“启动仪式”的任务，它会调用并执行在`/agents`中定义的**Agent**。
*   **Agent层 (`/agents`)**: 这是我们项目最“智能”的部分。
    *   `task_igniter_agent.py`会用LangGraph定义一个图(Graph)。这个图的节点(Node)可能是“调用LLM分解任务”、“查询向量数据库”、“查询关系数据库”等函数，边(Edge)则定义了这些节点之间的条件跳转逻辑。
*   **数据访问层 (`/crud`)**: 这一层封装了所有对SQLite的直接操作。服务层不应包含任何SQL语句，而应调用如`crud.task.create(db, task_data)`这样的函数。这使得未来如果想更换数据库（比如从SQLite换到PostgreSQL），我们只需要修改这一层的代码。

---

### **3. 数据库详细设计 (SQLite)**

数据库是“真理的源头”，它的设计原则是**“规范化、关系清晰、易于查询”**。

#### **3.1. 核心设计理念**

*   **实体-关系模型 (ERM)**：我们将每个核心概念（项目、笔记、任务、标签）抽象为一个“实体”（即一张表）。
*   **主键与外键**: 每个表都有一个唯一的`id`作为主键。表与表之间的关系通过“外键”来建立，确保数据的完整性和一致性。
*   **规范化 (Normalization)**：我们通过使用`note_tags`这样的连接表来处理“多对多”关系，避免了数据冗余，使得结构更加清晰和高效。

#### **3.2. 表结构详细解读**

*   **`projects`**: **组织者**。它是最高层级的容器，用于将不同领域的任务和笔记隔离开，方便聚焦。
*   **`notes`**: **知识的核心**。
    *   `content`字段存储了笔记的全部原文，是RAG和向量化的基础。
    *   `source_url`字段至关重要，它实现了“知识可追溯”这一核心需求。
*   **`tasks`**: **行动的核心**。
    *   `status`字段是任务管理的基础，`CHECK`约束保证了状态的有效性。
    *   `due_date`用于提醒，而`snooze_until`字段则是专门为“灵活延后”功能设计的，它记录了任务应该在何时被“唤醒”。
*   **`tags` 和 `note_tags`**: **知识的连接器**。
    *   这种设计允许一篇笔记拥有多个标签，也允许一个标签被用于多篇笔记，提供了极大的灵活性。
    *   `ON DELETE CASCADE`是一个重要的工程实践，它确保在删除一篇笔记或一个标签时，不会在连接表中留下无用的“孤儿”数据。
*   **`user_profile_memories`**: **个性的塑造者**。
    *   这张表独立于所有业务数据，专门用于存储助手对你的“认知”。
    *   `is_active`字段让你可以“软删除”或暂时禁用某条记忆，而不是物理删除，方便未来恢复。
